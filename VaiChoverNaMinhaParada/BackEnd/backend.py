# -*- coding: utf-8 -*-
"""Backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rmxMWB3utCDpW4CzBSBXx9aPDROUrgxf
"""
"""
script_bat = "setup.bat" 
try:
    subprocess.run([script_bat], shell=True,check=True)
except subprocess.CalledProcessError:
    sys.exit(1)
except FileNotFoundError:
    sys.exit(1)
"""

import subprocess
import sys
import os
import netrc
import requests
from requests.auth import HTTPBasicAuth
import io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from prophet import Prophet
from subprocess import Popen
import platform
import shutil
from subprocess import Popen
from getpass import getpass
import math
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import webbrowser
    
homeDir = os.path.expanduser("~") + os.sep

with open(homeDir + '.urs_cookies', 'w') as file:
    file.write('')
    file.close()
with open(homeDir + '.dodsrc', 'w') as file:
    file.write('HTTP.COOKIEJAR={}.urs_cookies\n'.format(homeDir))
    file.write('HTTP.NETRC={}.netrc'.format(homeDir))
    file.close()

print('Saved .urs_cookies and .dodsrc to:', homeDir)

if platform.system() == "Windows":
    shutil.copy2(homeDir + '.dodsrc', os.getcwd())
    print('Copied .dodsrc to:', os.getcwd())


urs = 'urs.earthdata.nasa.gov'    # Earthdata URL to call for authentication
prompts = ['Enter NASA Earthdata Login Username \n(or create an account at urs.earthdata.nasa.gov): ',
           'Enter NASA Earthdata Login Password: ']

homeDir = os.path.expanduser("~") + os.sep

with open(homeDir + '.netrc', 'w') as file:
    file.write('machine {} login {} password {}'.format(urs, ' igor_mariz7', 'Igormariz2003@'))
    file.close()

print('Saved .netrc to:', homeDir)
# nini1504
# Nicolly1504@

# igor_mariz7
# Igormariz2003@
# Set appropriate permissions for Linux/macOS
if platform.system() != "Windows":
    Popen('chmod og-rw ~/.netrc', shell=True)

# Setup the signin and time series URLs
signin_url = "https://api.giovanni.earthdata.nasa.gov/signin"
time_series_url = "https://api.giovanni.earthdata.nasa.gov/timeseries"

time_start = "2000-09-01T03:00:00"
time_end = "2025-09-30T21:00:00"

prefix = "GLDAS_NOAH025_3H_2_1"
variables = [
    "_Tair_f_inst",     # Temperatura
    "_Qair_f_inst",     # Umidade
    "_Rainf_tavg",      # Precipitação de chuva
    "_Snowf_tavg",      # Precipitação de neve
    "_Wind_f_inst",     # Velocidade do vento
    "_Psurf_f_inst"     # Pressão
]

token = requests.get(signin_url, auth=HTTPBasicAuth(netrc.netrc().hosts['urs.earthdata.nasa.gov'][0],
                                                    netrc.netrc().hosts['urs.earthdata.nasa.gov'][2]),
                     allow_redirects=True).text.replace('"','')

def call_time_series(lat,lon,time_start,time_end,data):
  responses = []
  for variable in variables:
    query_parameters = {
        "data":prefix+variable,
        "location":"[{},{}]".format(lat,lon),
        "time":"{}/{}".format(time_start,time_end)
    }
    headers = {"authorizationtoken":token}
    response=requests.get(time_series_url,params=query_parameters,headers=headers)
    responses.append(response.text)
  return responses

def parse_csv(resp):
    with io.StringIO(resp) as f:
        # the first 13 rows are header
        headers = {}
        f.read(1)
        for i in range(13):
            line = f.readline()
            #print(f"Processing line {i+1}: {line.strip()}") # Print the line being processed
            try:
                key,value = line.split(",")
            except ValueError:
                #print(f"Error splitting line {i+1}: {line.strip()}") # Indicate which line caused the error
                raise # Re-raise the exception after printing
            headers[key] = value.strip()
# Read the csv proper
        df = pd.read_csv(
            f,
            header=1,
            names=("Timestamp",headers["param_name"]),
            converters={"Timestamp":pd.Timestamp}
        )
    return headers, df
#%%time
resp = []

# for r in resp:
#   headers, df = parse_csv(r)
#   dataframes.append(df)


# dataframe = pd.DataFrame(columns=columns_name)
# result = []
# for df in dataframes:
#   df['Timestamp'] = pd.to_datetime(df['Timestamp'])
#   dataframe['data_obj'] = df['Timestamp'].dt.date
#   dataframe['hora_obj'] = df['Timestamp'].dt.time

#   df = pd.concat([dataframe, df], axis=1)
#   df = df[df['Timestamp'].dt.hour == int(time.split(':')[0])]
#   df = df.drop('Timestamp', axis=1)
#   df = df.drop('hora_obj', axis=1)

#   df.rename(columns={'data_obj': 'ds'}, inplace=True)

#   segunda_coluna = df.columns[1]
#   df.rename(columns={segunda_coluna: 'y'}, inplace=True)

#   m = Prophet()
#   m.fit(df)

#   future = m.make_future_dataframe(periods=365)
#   forecast = m.predict(future)
#   forecast = forecast[(forecast['ds'] == date)]
#   result.append(forecast['yhat'])
#print(result)

def umidade_relativa(q, T, P):
    """
    Converte umidade específica (kg/kg) em umidade relativa (%)

    Parâmetros:
    q : float : umidade específica (kg/kg)
    T : float : temperatura em °C
    P : float : pressão atmosférica em Pa
    """
    # Pressão de saturação do vapor d'água em Pa (fórmula de Tetens)
    e_s = 6.112 * math.exp((17.67 * T) / (T + 243.5)) * 100  # em Pa

    # Pressão parcial do vapor
    e = (q * P) / (0.622 + q)

    # Umidade relativa %
    RH = (e / e_s) * 100
    return RH

def estimar_chance_chuva(T, q, P, vento, precip):
    """
    Estima a chance de chuva (%) com base em variáveis atmosféricas.
    
    T: temperatura em °C
    q: umidade específica (kg/kg)
    P: pressão atmosférica em hPa
    vento: velocidade do vento (m/s)
    precip: taxa de precipitação (kg m-2 s-1)
    """
    RH = umidade_relativa(q, T, P * 100)  # converte P pra Pa
    Td = T-(100-RH)/5  # temperatura do ponto de orvalho
    
    k1 = 0.5
    k2 = 0.1
    k3 = 0.05
    
    P_chuva = k1*RH + k2*(1013-P)+k3*vento
    
    return P_chuva
# Lista com os nomes das variáveis na mesma ordem em que foram consultadas
# nomes_variaveis = [
#     "Temperatura",
#     "Umidade Específica",
#     "Precipitação de Chuva",
#     "Precipitação de Neve",
#     "Velocidade do Vento",
#     "Pressão Atmosférica"
# ]

# # Lista com as unidades correspondentes
# unidades = [
#     "K", # Lembre-se que sugerimos a conversão para Celsius
#     "kg/kg",
#     "kg m-2 s-1",
#     "kg m-2 s-1",
#     "m/s",
#     "Pa"
# ]

# # Extração e conversão dos valores para float
# T = float(result[0].iloc[0]) - 273.15   # °C
# q = float(result[1].iloc[0])            # kg/kg
# precip = float(result[2].iloc[0])       # kg m-2 s-1
# vento = float(result[4].iloc[0])        # m/s
# P = float(result[5].iloc[0]) / 100      # Pa → hPa (a função espera ~1010, não 101000)

# # Exibir informações
# print(f"--- Previsão do Clima para a data: {date} ---")
# for nome, valor_serie, unidade in zip(nomes_variaveis, result, unidades):
#     print(f"{nome}: {valor_serie.iloc[0]:.6f} {unidade}")

# print(f"Celsius: {T:.2f} °C")
# print(f"Fahrenheit: {(T * 1.8 + 32):.2f} °F")

# # Umidade relativa
# RH = umidade_relativa(q, T, P * 100)  # se ela usa Pa
#print(f"Umidade relativa: {RH:.2f}%")

# Chance de chuva
# print(f"Chance de chuva: {estimar_chance_chuva(T, q, P, vento, precip):.2f}%")


def result_forecast(lat,lon,date,time):
    resp = call_time_series(lat, lon, time_start, time_end, date)

    dataframes = []
    for r in resp:
        headers, df = parse_csv(r)
        dataframes.append(df)
    columns_name = ['data_obj', 'hora_obj']
    dataframe = pd.DataFrame(columns=columns_name)
    result = []
    for df in dataframes:
        df['Timestamp'] = pd.to_datetime(df['Timestamp'])
        dataframe['data_obj'] = df['Timestamp'].dt.date
        dataframe['hora_obj'] = df['Timestamp'].dt.time

        df = pd.concat([dataframe, df], axis=1)
        df = df[df['Timestamp'].dt.hour == int(time.split(':')[0])]
        df = df.drop('Timestamp', axis=1)
        df = df.drop('hora_obj', axis=1)

        df.rename(columns={'data_obj': 'ds'}, inplace=True)

        segunda_coluna = df.columns[1]
        df.rename(columns={segunda_coluna: 'y'}, inplace=True)

        m = Prophet()
        m.fit(df)

        future = m.make_future_dataframe(periods=365)
        forecast = m.predict(future)
        forecast = forecast[(forecast['ds'] == date)]
        result.append(forecast['yhat'])

    C = float(result[0].iloc[0]) - 273.15   # °C
    q = float(result[1].iloc[0])            # kg/kg
    precip = float(result[2].iloc[0])    
    neve = float(result[3].iloc[0])# kg m-2 s-1
    vento = float(result[4].iloc[0])        # m/s
    P = float(result[5].iloc[0]) / 100      # Pa → hPa (a função espera ~1010, não 101000)
    K = float(result[0].iloc[0])        # °K
    RH = umidade_relativa(q, C, P * 100)  # se ela usa Pa
    chance_chuva = estimar_chance_chuva(C, q, P, vento, precip)
    
    return {
        "Temperatura_C": C,
        "Temperatura_F": C * 1.8 + 32,
        "Umidade_Relativa": RH,
        "Chance_Chuva": chance_chuva,
        "Precipitacao_chuva": precip * 3600,
        "Precipitacao_neve": neve * 3600,
        "Velocidade_Vento": vento,
        "Pressao_Atmosferica": P ,
        "Temperatura_K": K
    }

app = Flask(__name__)
CORS(app)
@app.route('/')
def serve_frontend():
    return send_file('index.html')

@app.route('/<path:filename>')
def serve_static(filename):
    """Rota para servir arquivos estáticos (CSS, JS, etc.)."""
    full_path = os.path.join(os.getcwd(), filename)
    
    # Adicionamos verificação para segurança e 404
    if not os.path.exists(full_path):
        return "File not found", 404
    return send_file(full_path)

@app.route('/api/forecast', methods=['POST'])
def forecast_api():
    data = request.json
    lat = data.get('latitude')
    lon = data.get('longitude')
    # date = data.get('date', date)
    # time = data.get('time', time)
    timestamp = data.get('datetime')
    
    if not all([lat, lon, timestamp]):
        return jsonify({"error": "Missing required parameters"}), 400
    
    try:
        dt_obj = datetime.strptime(timestamp, '%Y-%m-%dT%H:%M')
        date = dt_obj.strftime('%Y-%m-%d')
        time = dt_obj.hour
        hour = (round(time / 3) * 3) % 24
        hour_str = f"{hour:02d}:00:00"
        result = result_forecast(lat, lon, date, hour_str)   

        
        return jsonify(result)     
    except Exception as e:
        print(f"API error: {e}")
        return jsonify({"error: "f"Internal server error {str(e)}"}), 500
    
if __name__ == '__main__':
    app.run(debug=True)
    

    