# -*- coding: utf-8 -*-
"""Backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rmxMWB3utCDpW4CzBSBXx9aPDROUrgxf
"""

pip install prophet

# Commented out IPython magic to ensure Python compatibility.
import netrc
import requests
from requests.auth import HTTPBasicAuth
import os
import io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
from datetime import datetime
from prophet import Prophet

from subprocess import Popen
import platform
import shutil
import os # Import os module here

homeDir = os.path.expanduser("~") + os.sep

# Create .urs_cookies and .dodsrc files
with open(homeDir + '.urs_cookies', 'w') as file:
    file.write('')
    file.close()
with open(homeDir + '.dodsrc', 'w') as file:
    file.write('HTTP.COOKIEJAR={}.urs_cookies\n'.format(homeDir))
    file.write('HTTP.NETRC={}.netrc'.format(homeDir))
    file.close()

print('Saved .urs_cookies and .dodsrc to:', homeDir)

# Copy dodsrc to working directory in Windows
if platform.system() == "Windows":
    shutil.copy2(homeDir + '.dodsrc', os.getcwd())
    print('Copied .dodsrc to:', os.getcwd())

from subprocess import Popen
from getpass import getpass
import platform
import os
import shutil

urs = 'urs.earthdata.nasa.gov'    # Earthdata URL to call for authentication
prompts = ['Enter NASA Earthdata Login Username \n(or create an account at urs.earthdata.nasa.gov): ',
           'Enter NASA Earthdata Login Password: ']

homeDir = os.path.expanduser("~") + os.sep

with open(homeDir + '.netrc', 'w') as file:
    file.write('machine {} login {} password {}'.format(urs, getpass(prompt=prompts[0]), getpass(prompt=prompts[1])))
    file.close()

print('Saved .netrc to:', homeDir)
# nini1504
# Nicolly1504@
# Set appropriate permissions for Linux/macOS
if platform.system() != "Windows":
    Popen('chmod og-rw ~/.netrc', shell=True)

# Setup the signin and time series URLs
signin_url = "https://api.giovanni.earthdata.nasa.gov/signin"
time_series_url = "https://api.giovanni.earthdata.nasa.gov/timeseries"

lat = -18.9113
lon = -48.2622
time_start = "2000-09-01T03:00:00"
time_end = "2025-09-30T21:00:00"
data = "GLDAS_NOAH025_3H_2_1_Tair_f_inst"
time = "06:00:00"
date = "2025-10-05"

prefix = "GLDAS_NOAH025_3H_2_1"
variables = [
    "_Tair_f_inst", # Temperatura
    "_Qair_f_inst", # Umidade
    "_Rainf_tavg",  # Precipitação de chuva
    "_Snowf_tavg",  # Precipitação de neve
    "_Wind_f_inst",  # Velocidade do vento
    "_Psurf_f_inst"   # Pressão
]

token = requests.get(signin_url, auth=HTTPBasicAuth(netrc.netrc().hosts['urs.earthdata.nasa.gov'][0],
                                                    netrc.netrc().hosts['urs.earthdata.nasa.gov'][2]),
                     allow_redirects=True).text.replace('"','')

def call_time_series(lat,lon,time_start,time_end,data):
  responses = []
  for variable in variables:
    query_parameters = {
        "data":prefix+variable,
        "location":"[{},{}]".format(lat,lon),
        "time":"{}/{}".format(time_start,time_end)
    }
    headers = {"authorizationtoken":token}
    response=requests.get(time_series_url,params=query_parameters,headers=headers)
    responses.append(response.text)
  return responses

def parse_csv(resp):
    with io.StringIO(resp) as f:
        # the first 13 rows are header
        headers = {}
        for i in range(13):
            line = f.readline()
            print(f"Processing line {i+1}: {line.strip()}") # Print the line being processed
            try:
                key,value = line.split(",")
            except ValueError:
                print(f"Error splitting line {i+1}: {line.strip()}") # Indicate which line caused the error
                raise # Re-raise the exception after printing
            headers[key] = value.strip()
# Read the csv proper
        df = pd.read_csv(
            f,
            header=1,
            names=("Timestamp",headers["param_name"]),
            converters={"Timestamp":pd.Timestamp}
        )
    return headers, df

# Commented out IPython magic to ensure Python compatibility.
# %%time
# resp = []
# resp = call_time_series(lat,lon,time_start,time_end,data)

dataframes = []

for r in resp:
  headers, df = parse_csv(r)
  dataframes.append(df)

columns_name = ['data_obj', 'hora_obj']
dataframe = pd.DataFrame(columns=columns_name)
result = []
for df in dataframes:
  df['Timestamp'] = pd.to_datetime(df['Timestamp'])
  dataframe['data_obj'] = df['Timestamp'].dt.date
  dataframe['hora_obj'] = df['Timestamp'].dt.time

  df = pd.concat([dataframe, df], axis=1)
  df = df[df['Timestamp'].dt.hour == int(time.split(':')[0])]
  df = df.drop('Timestamp', axis=1)
  df = df.drop('hora_obj', axis=1)

  df.rename(columns={'data_obj': 'ds'}, inplace=True)

  segunda_coluna = df.columns[1]
  df.rename(columns={segunda_coluna: 'y'}, inplace=True)

  m = Prophet()
  m.fit(df)

  future = m.make_future_dataframe(periods=365)
  forecast = m.predict(future)
  forecast = forecast[(forecast['ds'] == date)]
  result.append(forecast['yhat'])
print(result)

import math

def umidade_relativa(q, T, P):
    """
    Converte umidade específica (kg/kg) em umidade relativa (%)

    Parâmetros:
    q : float : umidade específica (kg/kg)
    T : float : temperatura em °C
    P : float : pressão atmosférica em Pa
    """
    # Pressão de saturação do vapor d'água em Pa (fórmula de Tetens)
    e_s = 6.112 * math.exp((17.67 * T) / (T + 243.5)) * 100  # em Pa

    # Pressão parcial do vapor
    e = (q * P) / (0.622 + q)

    # Umidade relativa %
    RH = (e / e_s) * 100
    return RH

# Lista com os nomes das variáveis na mesma ordem em que foram consultadas
nomes_variaveis = [
    "Temperatura",
    "Umidade Específica",
    "Precipitação de Chuva",
    "Precipitação de Neve",
    "Velocidade do Vento",
    "Pressão Atmosférica"
]

# Lista com as unidades correspondentes
unidades = [
    "K", # Lembre-se que sugerimos a conversão para Celsius
    "kg/kg",
    "kg m-2 s-1",
    "kg m-2 s-1",
    "m/s",
    "Pa"
]

c = result[0] - 273.15

fh = (result[0] - 273.15)*1.8+32

print(f"--- Previsão do Clima para a data: {date} ---")

# O 'zip' combina as duas listas, permitindo percorrer ambas ao mesmo tempo
for nome, valor_serie, unidade in zip(nomes_variaveis, result, unidades):
    # Usamos .iloc[0] para extrair apenas o número de dentro da Série do Pandas
    # Usamos :.4f para formatar o número, mostrando apenas 4 casas decimais
    valor_numerico = valor_serie.iloc[0]
    print(f"{nome}: {valor_numerico:.6f} {unidade}")
print(f'Celsius: {c}\n')
print(f'Fahrenheit: {fh}\n')

q = float(result[1].iloc[0])        # kg/kg
T = float(result[0].iloc[0]) - 273.15   # °C
P = float(result[5].iloc[0])        # Pa

RH = umidade_relativa(q, T, P)
print(f"Umidade relativa: {RH:.2f}%")