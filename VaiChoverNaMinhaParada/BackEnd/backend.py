# -*- coding: utf-8 -*-
"""Backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rmxMWB3utCDpW4CzBSBXx9aPDROUrgxf
"""
"""
script_bat = "setup.bat" 
try:
    subprocess.run([script_bat], shell=True,check=True)
except subprocess.CalledProcessError:
    sys.exit(1)
except FileNotFoundError:
    sys.exit(1)
"""

import subprocess
import sys
import os
import netrc
import requests
from requests.auth import HTTPBasicAuth
import io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from prophet import Prophet
from subprocess import Popen
import platform
import shutil
from subprocess import Popen
from getpass import getpass
import math
    
homeDir = os.path.expanduser("~") + os.sep

with open(homeDir + '.urs_cookies', 'w') as file:
    file.write('')
    file.close()
with open(homeDir + '.dodsrc', 'w') as file:
    file.write('HTTP.COOKIEJAR={}.urs_cookies\n'.format(homeDir))
    file.write('HTTP.NETRC={}.netrc'.format(homeDir))
    file.close()

print('Saved .urs_cookies and .dodsrc to:', homeDir)

if platform.system() == "Windows":
    shutil.copy2(homeDir + '.dodsrc', os.getcwd())
    print('Copied .dodsrc to:', os.getcwd())


urs = 'urs.earthdata.nasa.gov'    # Earthdata URL to call for authentication
prompts = ['Enter NASA Earthdata Login Username \n(or create an account at urs.earthdata.nasa.gov): ',
           'Enter NASA Earthdata Login Password: ']

homeDir = os.path.expanduser("~") + os.sep

with open(homeDir + '.netrc', 'w') as file:
    file.write('machine {} login {} password {}'.format(urs, getpass(prompt=prompts[0]), getpass(prompt=prompts[1])))
    file.close()

print('Saved .netrc to:', homeDir)
# nini1504
# Nicolly1504@

# igor_mariz7
# Igormariz2003@
# Set appropriate permissions for Linux/macOS
if platform.system() != "Windows":
    Popen('chmod og-rw ~/.netrc', shell=True)

# Setup the signin and time series URLs
signin_url = "https://api.giovanni.earthdata.nasa.gov/signin"
time_series_url = "https://api.giovanni.earthdata.nasa.gov/timeseries"

lat = -18.9113
lon = -48.2622
time_start = "2000-09-01T03:00:00"
time_end = "2025-09-30T21:00:00"
data = "GLDAS_NOAH025_3H_2_1_Tair_f_inst"
time = "06:00:00"
date = "2025-10-06"

prefix = "GLDAS_NOAH025_3H_2_1"
variables = [
    "_Tair_f_inst",     # Temperatura
    "_Qair_f_inst",     # Umidade
    "_Rainf_tavg",      # Precipitação de chuva
    "_Snowf_tavg",      # Precipitação de neve
    "_Wind_f_inst",     # Velocidade do vento
    "_Psurf_f_inst"     # Pressão
]

token = requests.get(signin_url, auth=HTTPBasicAuth(netrc.netrc().hosts['urs.earthdata.nasa.gov'][0],
                                                    netrc.netrc().hosts['urs.earthdata.nasa.gov'][2]),
                     allow_redirects=True).text.replace('"','')

def call_time_series(lat,lon,time_start,time_end,data):
  responses = []
  for variable in variables:
    query_parameters = {
        "data":prefix+variable,
        "location":"[{},{}]".format(lat,lon),
        "time":"{}/{}".format(time_start,time_end)
    }
    headers = {"authorizationtoken":token}
    response=requests.get(time_series_url,params=query_parameters,headers=headers)
    responses.append(response.text)
  return responses

def parse_csv(resp):
    with io.StringIO(resp) as f:
        # the first 13 rows are header
        headers = {}
        f.read(1)
        for i in range(13):
            line = f.readline()
            #print(f"Processing line {i+1}: {line.strip()}") # Print the line being processed
            try:
                key,value = line.split(",")
            except ValueError:
                #print(f"Error splitting line {i+1}: {line.strip()}") # Indicate which line caused the error
                raise # Re-raise the exception after printing
            headers[key] = value.strip()
# Read the csv proper
        df = pd.read_csv(
            f,
            header=1,
            names=("Timestamp",headers["param_name"]),
            converters={"Timestamp":pd.Timestamp}
        )
    return headers, df
#%%time
resp = []
resp = call_time_series(lat,lon,time_start,time_end,data)

dataframes = []

for r in resp:
  headers, df = parse_csv(r)
  dataframes.append(df)

columns_name = ['data_obj', 'hora_obj']
dataframe = pd.DataFrame(columns=columns_name)
result = []
for df in dataframes:
  df['Timestamp'] = pd.to_datetime(df['Timestamp'])
  dataframe['data_obj'] = df['Timestamp'].dt.date
  dataframe['hora_obj'] = df['Timestamp'].dt.time

  df = pd.concat([dataframe, df], axis=1)
  df = df[df['Timestamp'].dt.hour == int(time.split(':')[0])]
  df = df.drop('Timestamp', axis=1)
  df = df.drop('hora_obj', axis=1)

  df.rename(columns={'data_obj': 'ds'}, inplace=True)

  segunda_coluna = df.columns[1]
  df.rename(columns={segunda_coluna: 'y'}, inplace=True)

  m = Prophet()
  m.fit(df)

  future = m.make_future_dataframe(periods=365)
  forecast = m.predict(future)
  forecast = forecast[(forecast['ds'] == date)]
  result.append(forecast['yhat'])
#print(result)

def umidade_relativa(q, T, P):
    """
    Converte umidade específica (kg/kg) em umidade relativa (%)

    Parâmetros:
    q : float : umidade específica (kg/kg)
    T : float : temperatura em °C
    P : float : pressão atmosférica em Pa
    """
    # Pressão de saturação do vapor d'água em Pa (fórmula de Tetens)
    e_s = 6.112 * math.exp((17.67 * T) / (T + 243.5)) * 100  # em Pa

    # Pressão parcial do vapor
    e = (q * P) / (0.622 + q)

    # Umidade relativa %
    RH = (e / e_s) * 100
    return RH

def estimar_chance_chuva(T, q, P, vento, precip):
    """
    Estima a chance de chuva (%) com base em variáveis atmosféricas.
    
    T: temperatura em °C
    q: umidade específica (kg/kg)
    P: pressão atmosférica em hPa
    vento: velocidade do vento (m/s)
    precip: taxa de precipitação (kg m-2 s-1)
    """
    RH = umidade_relativa(q, T, P * 100)  # converte P pra Pa
    Td = T-(100-RH)/5  # temperatura do ponto de orvalho
    
    k1 = 0.5
    k2 = 0.1
    k3 = 0.05
    
    P_chuva = k1*RH + k2*(1013-P)+k3*vento
    
    return P_chuva
# Lista com os nomes das variáveis na mesma ordem em que foram consultadas
nomes_variaveis = [
    "Temperatura",
    "Umidade Específica",
    "Precipitação de Chuva",
    "Precipitação de Neve",
    "Velocidade do Vento",
    "Pressão Atmosférica"
]

# Lista com as unidades correspondentes
unidades = [
    "K", # Lembre-se que sugerimos a conversão para Celsius
    "kg/kg",
    "kg m-2 s-1",
    "kg m-2 s-1",
    "m/s",
    "Pa"
]

# Extração e conversão dos valores para float
T = float(result[0].iloc[0]) - 273.15   # °C
q = float(result[1].iloc[0])            # kg/kg
precip = float(result[2].iloc[0])       # kg m-2 s-1
vento = float(result[4].iloc[0])        # m/s
P = float(result[5].iloc[0]) / 100      # Pa → hPa (a função espera ~1010, não 101000)

# Exibir informações
print(f"--- Previsão do Clima para a data: {date} ---")
for nome, valor_serie, unidade in zip(nomes_variaveis, result, unidades):
    print(f"{nome}: {valor_serie.iloc[0]:.6f} {unidade}")

print(f"Celsius: {T:.2f} °C")
print(f"Fahrenheit: {(T * 1.8 + 32):.2f} °F")

# Umidade relativa
RH = umidade_relativa(q, T, P * 100)  # se ela usa Pa
print(f"Umidade relativa: {RH:.2f}%")

# Chance de chuva
print(f"Chance de chuva: {estimar_chance_chuva(T, q, P, vento, precip):.2f}%")