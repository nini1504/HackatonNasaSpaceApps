# -*- coding: utf-8 -*-
"""coletaInicial

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vEBx_FJHjWVW1Ub_d_LXo49IRueF8xRb
"""

# Commented out IPython magic to ensure Python compatibility.
import netrc
import requests
from requests.auth import HTTPBasicAuth
import os
import io
import pandas
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

from subprocess import Popen
import platform
import shutil
import os # Import os module here

homeDir = os.path.expanduser("~") + os.sep

# Create .urs_cookies and .dodsrc files
with open(homeDir + '.urs_cookies', 'w') as file:
    file.write('')
    file.close()
with open(homeDir + '.dodsrc', 'w') as file:
    file.write('HTTP.COOKIEJAR={}.urs_cookies\n'.format(homeDir))
    file.write('HTTP.NETRC={}.netrc'.format(homeDir))
    file.close()

print('Saved .urs_cookies and .dodsrc to:', homeDir)

# Copy dodsrc to working directory in Windows
if platform.system() == "Windows":
    shutil.copy2(homeDir + '.dodsrc', os.getcwd())
    print('Copied .dodsrc to:', os.getcwd())

from subprocess import Popen
from getpass import getpass
import platform
import os
import shutil

urs = 'urs.earthdata.nasa.gov'    # Earthdata URL to call for authentication
prompts = ['Enter NASA Earthdata Login Username \n(or create an account at urs.earthdata.nasa.gov): ',
           'Enter NASA Earthdata Login Password: ']

homeDir = os.path.expanduser("~") + os.sep

with open(homeDir + '.netrc', 'w') as file:
    file.write('machine {} login {} password {}'.format(urs, getpass(prompt=prompts[0]), getpass(prompt=prompts[1])))
    file.close()

print('Saved .netrc to:', homeDir)

# Set appropriate permissions for Linux/macOS
if platform.system() != "Windows":
    Popen('chmod og-rw ~/.netrc', shell=True)

# Setup the signin and time series URLs
signin_url = "https://api.giovanni.earthdata.nasa.gov/signin"
time_series_url = "https://api.giovanni.earthdata.nasa.gov/timeseries"

lat = -18.9113
lon = -48.2622
time_start = "2025-01-01T00:00:00"
time_end = "2025-09-30T00:00:00"
data = "GLDAS_NOAH025_3H_2_1_Tair_f_inst"

token = requests.get(signin_url, auth=HTTPBasicAuth(netrc.netrc().hosts['urs.earthdata.nasa.gov'][0],
                                                    netrc.netrc().hosts['urs.earthdata.nasa.gov'][2]),
                     allow_redirects=True).text.replace('"','')

def call_time_series(lat,lon,time_start,time_end,data):
    """
    INPUTS:
    lat - latitude
    lon - longitude
    time_start - start of time series in YYYY-MM-DDThh:mm:ss format (UTC)
    end_time - end of the time series in YYYY-MM-DDThh:mm:ss format (UTC)
    data - name of the data parameter for the time series

    OUTPUT:
    time series csv output string
    """
    query_parameters = {
        "data":data,
        "location":"[{},{}]".format(lat,lon),
        "time":"{}/{}".format(time_start,time_end)
    }
    headers = {"authorizationtoken":token}
    response=requests.get(time_series_url,params=query_parameters,headers=headers)
    return response.text

def parse_csv(ts):
    """
    INPUTS:
    ts - time series output of the time series service

    OUTPUTS:
    headers,df - the headers from the CSV as a dict and the values in a pandas dataframe
    """
    with io.StringIO(ts) as f:
        # the first 13 rows are header
        headers = {}
        for i in range(13):
            line = f.readline()
            print(f"Processing line {i+1}: {line.strip()}") # Print the line being processed
            try:
                key,value = line.split(",")
            except ValueError:
                print(f"Error splitting line {i+1}: {line.strip()}") # Indicate which line caused the error
                raise # Re-raise the exception after printing
            headers[key] = value.strip()

        # Read the csv proper
        df = pandas.read_csv(
            f,
            header=1,
            names=("Timestamp",headers["param_name"]),
            converters={"Timestamp":pandas.Timestamp}
        )

    return headers, df

# Commented out IPython magic to ensure Python compatibility.
# %%time
# ts = call_time_series(lat,lon,time_start,time_end,data)
# print(ts)

headers,df = parse_csv(ts)
print(df.head())

ax = plt.gca()
df.plot(x="Timestamp",y=headers["param_name"],ax=ax)
ax.set_ylabel(headers["unit"])
ax.set_title("{} at [{},{}]".format(data,headers["lat"],headers["lon"]))